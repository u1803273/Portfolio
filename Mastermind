--------------------------------------------------------------------------------
-- Functional Programming (CS141)                                             --
-- Coursework 1: Mastermind                                                   --
--------------------------------------------------------------------------------

-- | This module should contain your game code.
module Game where

--------------------------------------------------------------------------------

-- I perform list difference within score, and so I need to import Data.List
import Data.List

--This is for use in the eliminate function
import Data.Function (on)

-- | The number of pegs in a code.
pegs :: Int
pegs = 4

-- | Symbols are represented by characters.
type Symbol = Char

-- | The available symbols in the game.
symbols :: [Symbol]
symbols = ['a'..'f']

-- | A code is represented by a list of symbols.
type Code = [Symbol]

-- Used to store a tuple, each element a list of integers
type Index = ([Int],[Int])

-- | Guesses are scored using coloured and white markers. The first component
-- of the pair gives the number of coloured markers and the right component
-- gives the number of white markers.
type Score = (Int, Int)

-- | A player is either human or computer-controlled.
data Player = Human | Computer | Training

-- | The first codemaker in a play session.
codemaker :: Player
codemaker = Human


-- | The first guess the AI will make.
firstGuess :: Code
firstGuess = "aabb"

--------------------------------------------------------------------------------

-- | Determines whether a score indicates that a guess was correct or not.
------------------------------------
{-
  If a guess is correct, then all pegs will be coloured and so the first integer of score will be equal to the value of pegs.
  We use the fst function to extract this first value
  If this is true we return True, else we return false
-}
correctGuess :: Score -> Bool
correctGuess score = fst score == pegs




-- This function should check that the code entered by a human player is
-- valid. In other words, it should have the length given by `pegs` and it
-- should only contain valid symbols.
------------------------------------
{-
  If the length is correct, AND the characters are all valid, then the function should return true. Else, it returns false.
  The first expression checks that length is equal to the value of pegs
  The second uses the all keyword to check that every character of code is a member of symbols (and so a valid character)
-}
validateCode :: Code -> Bool
validateCode xs = (length xs == pegs) && all (`elem` symbols) xs



-- | This function generates all possible codes.
------------------------------------
{-
  The codes function needs to generate codes for a varying length of pegs. This means that it has to build up
  the list of codes, and stop once each code has length of pegs. It calls the generateCodes function and passes in pegs
  (the length of each code generated) and the empty list, which will end as a list of codes
-}

codes :: [Code]
codes = generateCodes pegs []

{-
  When generateCodes is initially called, then depending on the value of pegs, either;
      0 list in which the empty list is returned
      pegs [] in which pegs is >0 and so the function is called recurisvely, which a decremented pegs, and a list
      equal to that of symbols.
  With each recursive call, each element of the list is taken, and every character from symbols is taken and
  added to the list (using the b:a function to add b to the list a).
  This means that with every call, the list is increasing sixfold. This repeats until pegs is 0, and we have a list of codes
  of our desired length
-}
generateCodes :: Int -> [Code] -> [Code]
generateCodes 0 list = list
generateCodes pegs [] = generateCodes (pegs-1) [[a] | a <- symbols]
generateCodes pegs list = generateCodes (pegs-1) [b:a | a <- list, b <- symbols]
-- I initially used a ++ [b] to append the two lists together, but b:a is more efficient



-- | All possible scores.
------------------------------------
{-
  The game is won when all markers are coloured
  There are various combinations inbetween this and then 0
  Therefore, the output is a list of pairs of numbers, which at most sum to pegs (the reason for the a + b <= pegs)
  Cannot have (3,1) (taking pegs as length 4) because if 3 are in the correct position and you have the fourth colour,
  it has to be in the correct position also, as there is nowhere else it could be. This is generalised to (pegs -1, 1)
-}
results :: [Score]
results = [ (a,b) | a <- [0..pegs], b <- [0..pegs], a + b <= pegs, (a,b) /= (pegs-1,1)]




-----------------------------------
{-
  This function is used to calculate the score of a given code and the guess.
  A is calculated as follows;
      The lists code and guess are zipped together, to form a new list of lists, with each element being a list of the
      values within code and guess at that index.
      This means, that we can take each list, and if the values are indentical, then the colour and the location are both correct
      and so for every one of these, a black peg needs to be awarded.
      The filter function is used to apply this predicate, and the length of the resulting list is the no. of coloured pegs to return
  B is calculated by finding list difference of code and guess. This means that every color that appears in both lists is removed.
  Subtracting the new reduced length of this list from the original length of code tells us how many matching colours there were,
  including the sum of both white and black pegs. Taking away a (no. of black pegs) leaves the number of whites
-}
score :: Code -> Code -> Score
score code guess = (a,b)
  where
    a = length ( filter (\x -> fst x == snd x) (zip code guess))
    b = length code - length (code \\ guess) - a






-- | Chooses the next guess. If there is only one option left, choose it.
-- Otherwise, calculate the hit score for each code and choose the code
-- with the largest hit score.
------------------------------------
{-
  There are three options to choose from. Either there is one code left in s in which case choose that. Otherwise, it needs
  to choose a value which will remove the largest number of scores from s, preferably choosing one in s than one not. The three
  guards of the function follow this order, with control falling through them as the predicates arent met.
      Scores holds a list. Every code is iterated through, and for each, it is passed into the function smallest score. This returns
  the biggest guaranteed hit score. The code and the score are stored as a tuple. Score is sorted, so that the lowest score is first
  and the highest score/code tuple is at the end of the list.
  Hitsscore is set to the last score in the list (or the greatest)
  However, there could be multiple codes that generate this score. Therefore reducedS stores only those codes that have an identical
  score and are in s. Any of these codes can be chosen, and so the first one is. If this list is 0, there were no codes in s to try,
  and so the code that generated the biggest hit score is chosen.
-}


nextGuess :: [Code] -> Code
nextGuess s
  | length s == 1 = head s
  | length reducedS > 0 = snd (head sortedReducedS)
  -- | not (null reducedS) = snd (last reducedS)
  | otherwise = snd (last scores)
    where
      scores = sortBy (compare `on` fst) [ ( m, i) | i<- codes,  let m = smallestScore s i]
      hitScore = fst (last scores)
      reducedS = [ i | i <- scores, let m = fst i, let n = snd i, (m == hitScore) && (n `elem` s)]
      -- There was an error whereby sometimes choosing the first item in the reducedS list resulted in the algorithm
      -- correctly calculating the code, and times when it couldn't but where choosing the last item did.
      -- Therefore sortedReducedS sorts the codes alphabetically, and thus always choose a code with a lower value over others
      sortedReducedS = sortBy (compare `on` snd) reducedS
      --sortedScores = sortBy (compare `on` snd) scores

{-
nextGuess :: [Code] -> Code
nextGuess s
  | length s == 1 = head s
  | not (null reducedS) = snd (head sortedReducedS)
  -- | not (null reducedS) = snd (last reducedS)
  | otherwise = snd (last scores)
    where
      scores = sort [ ( m, i) | i<- codes,  let m = smallestScore s i]
      hitScore = fst (last scores)
      reducedS = [ i | i <- scores, let m = fst i, let n = snd i, (m == hitScore) && elem n s]
      -- There was an error whereby sometimes choosing the first item in the reducedS list resulted in the algorithm
      -- correctly calculating the code, and times when it couldn't but where choosing the last item did.
      -- Therefore sortedReducedS sorts the codes alphabetically, and thus always choose a code with a lower value over others
      --sortedReducedS = sortBy (compare `on` snd) reducedS
-}


{-
  This function takes a code, runs it against the 14 possible results it could get,m produces a list of integers
  of the number of values from s it would remove, and then returns the smallest value (the worst case scenario)
-}
smallestScore :: [Code] -> Code -> Int
smallestScore s code = minimum [ length s - length a | i <- results, let a = eliminate i code s]






-- | Remove all codes from the remaining possibilities which would result in
-- a different score for the guess if they were the code.
-- In other words, given the set of remaining possible codes, narrow it down
-- to those which would produce the same score we got from the codemaker.
------------------------------------
{-
  The list comprehension goes through every code in the list codes.
  For each one, it passes it into the score function, along with the guess, and the score is returned.
  If the score is the same as lastscore, then it gets returned.
-}
eliminate :: Score -> Code -> [Code] -> [Code]
eliminate lastScore guess codes = [ i  | i <- codes, let m = score i guess, m == lastScore]




-------------------------------------------------------------
                --Extra Improvements--
-------------------------------------------------------------





-- This function is used by the UI to validate the input from the user to determine which mode they had selected
validateMode :: String -> Bool
validateMode mode = mode == "1" || mode == "2" || mode == "3"

-- This function takes in a guess and iterates through it, and adds each character to the end of an empty string.
-- SplitAt isolates the last character from the list, and takes it and adds to the end of the string
-- By isolating each character, we can determine whether it is deserving of being outputted as blue or pink.
-- The color function determines what colour it should be.
-- snd x is the second value from the result of the splitAt function (a list of a single character)

-- When color is called, it passes in the fullcode. However, this meant that if characters repeated in the guess but were only present once in the
-- guess they were coloured multiple times which is incorrect. Therefore, we need to remove an element from the code after every iteration. Prev is used
-- to store the previous element (so that we can remove it, to prevent duplicates)

gameBoard :: Code -> Code -> Code -> Int -> {-Code -> Index-> -}String
gameBoard guess code fullCode pegs {-prev indexes-}
  | pegs == 0 = "| "
  | otherwise = gameBoard (fst x) (fst y) (fullCode \\ snd x) (pegs -1) {-(snd x)-} ++ color (snd x) (snd y) fullCode {- fullGuess  (pegs-1) indexes-}
  where
    x = splitAt (pegs-1) guess
    y = splitAt (pegs-1) code


blueRemoval :: Code -> Code -> Code -> Int -> Code
--blueRemoval code guess = code \\ [ i | i <- pegs, code !! i == guess !! i]
blueRemoval code fullCode guess pegs
  | pegs == 0 = fullCode
  | code !! (pegs-1) == guess !! (pegs-1) = blueRemoval (fst x) (fullCode \\ [(guess !! (pegs-1))]) (fst y) (pegs-1)
  | otherwise = blueRemoval (fst x) fullCode (fst y) (pegs-1)
    where
      x = splitAt (pegs-1) guess
      y = splitAt (pegs-1) code


{-}
blueRemoval guess code pegs fullCode
  | pegs ==0 = fullCode
  | otherwise do
    if (fst x == fst y) then
      fullCode \\ fst x
    blueRemoval (fst x) (fst y) fullCode
    where
      x = splitAt (pegs -1) guess
      y = splitAt (pegs -1) code

-}

-- This function returns the string to be appended, but with the correct color.
-- Index is the index of the symbol in the code that we are examining
-- indexColor checks whether the two characters passed in are equal (and so they also have an equal index and so
-- should be coloured blue)

color :: Code -> Code -> Code  -> {-Index->-} String
color x y fullCode  --index indexes
    -- Deals with the coloured pegs
    | x == y = "\x1b[36m" ++ x ++ "\x1b[0m"
    -- Deals with white pegs
    | head x `elem` fullCode = "\x1b[35m" ++ x ++ "\x1b[0m"
    -- All other characters are white
    | otherwise = x



-- This function creates the game board for the comp loop function (all characters ouputted are the same color as it does not rank them based on whether their position is correct or not)
compBoard :: Code -> Code -> Int -> String
compBoard guess code pegs
  | pegs == 0 = "| "
  | otherwise = compBoard (fst x) (fst y) (pegs -1) ++ "\x1b[36m" ++ snd x ++ "\x1b[0m"
  where
    x = splitAt (pegs-1) guess
    y = splitAt (pegs-1) code



--------------------------------------------------------------------------------

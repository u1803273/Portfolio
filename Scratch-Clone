--------------------------------------------------------------------------------
-- Functional Programming (CS141)                                             --
-- Coursework 2: Scratch clone                                                --
--------------------------------------------------------------------------------

module Interpreter where

--------------------------------------------------------------------------------

import Language
import           Data.Maybe

--------------------------------------------------------------------------------

-- | In our memory, named locations map to values.
type Memory = [(String, Int)]

-- | Enumerates reasons for errors.
data Err
    = DivByZeroError                    -- ^ Division by zero was attempted.
    | NegativeExponentError             -- ^ Raising a number to a negative
                                        -- exponent was attempted.
    | UninitialisedMemory String        -- ^ Tried to read from a variable
                                        -- that does not exist.
    deriving (Eq, Show)

-- In opError and comparitive we pass functions as parameters
type BooleanFunction = (Int -> Int -> Bool)
type ArithmaticFunction = (Int -> Int -> Int)


--------------------------------------------------------------------------------

-- EXTENSIONS
-- I implemented the code for a while loop. This is tested within Spec.hs
-- I added boolean operators (AND, OR) and boolean operands True and False.
-- There are substantial tests for these inside spec.hs


--------------------------------------------------------------------------------


{-
Given a program and the initial memory contents, determines what evaluating the program does to the memory.

Interpret returns the new memory, or the exception that occurred when interpreting.
The second case takes the current statement and calls the statement function which deals with it
This will return the new memory or an error statement. The >>= operator will bind this new memory or error into the
variable x, which is then passed into the next recursive call, as the memory parameter. If there was an error,
the monad instance of either will, regardless of the next function, return the error.
If the statement was correct, then an either memory type will be returned. The bind operator extracts the memory
from the either container, and passes it into the statement function, as a new parameter, so that the new memory can be used
subsequently within the function
-}

interpret :: Program -> Memory -> Either Err Memory
-- If no program, or end of recursive call, return the state of the memory
interpret [] mem = Right mem
-- Otherwise, we have a program to deal with
interpret (x:xs) mem = statement x mem >>= \y -> interpret xs y


-- This takes a statement and returns the memory after it runs, or the error that occurred when running
-- Uses pattern matching to decide whether the statement is assignment, or an if or repeat construct.
-- I decided to pass in the multiple components of each statement (as in assignStmt x y mem) as oppose to (assignStmt (AssignStmt x y) mem) so that
-- in each function call there is no need to reference the data type and get the value associated with each label.
statement :: Stmt -> Memory -> Either Err Memory
statement (AssignStmt x y ) mem = assignStmt x y mem
statement (IfStmt w x y z) mem = ifStmt w x y z mem
-- Evaluates the expression for the number of times the loop should repeat, and binds this as the variable z into the repeatStmt function call
-- Any error in the expression will propogate and the program will stop.
statement (RepeatStmt x y) mem = evaluate x mem >>= \z -> repeatStmt z y mem
-- EXTENSION
statement (WhileStmt x y ) mem = whileStmt x y mem


-- Evaluate can return errors, and so we use the bind to ensure that if an error is returned, then
-- the memory isn't updated, and so retains the state it occupied before. Should there not be an error, then evaluate has returned an int.
-- This value is removed from its either container and bound to the variable y, and then the memory updated accordingly
assignStmt :: String -> Expr -> Memory -> Either Err Memory
assignStmt name value mem = evaluate value mem >>= \y -> Right (mem_removed ++ [(name, y)])
  where
    -- Every variable is initially set to 0, and so simply concatenating the new variable to the end of memory is
    -- insufficient as this causes duplicates
    -- Therefore, we return the list without the variable we want to replace.
    -- This means we can just concatenate a new value to the end of the list
    mem_removed = [x | x<- mem, fst x /= name ]




{-
    These arrays are used within the evaluate function. Instead of having eleven case statements for each operator, I grouped them into two lists, with all operators in each
    list having similar attributes. These two groups were the arithmatic operators and the boolean ones.
    Now, when the function is called, an operator is passed in as a parameter. We check whether it is in either list, and run the corresponding code. Now we only have to check
    two possibilities as oppose to the previous 11.
-}


-- Defines a list with all boolean operations stored as strings, and then the corresponding operator
booleanOperatorList :: [(String, BooleanFunction)]
booleanOperatorList = [("Equal",(==)),("Neq",(/=)),("GreaterThan",(>)),("GreaterOrEqual",(>=)),("LessThan",(<)),("LessOrEqual",(<=))] -- :: [(String, Int -> Int -> Bool)]
-- Defines a listwith all arithmatic operators stored as strings, and then the corresponding operator
operatorList = [("Add", (+)), ("Sub", (-)), ("Mul", (*))]


-- This function takes an expression and evaluates it. It will return an int if the expression evaluated correctly, or an error if it didn't.
evaluate :: Expr -> Memory -> Either Err Int
-- When the expression is an integer value, we just return the value
evaluate (ValE x) mem = Right x
-- When the expression is a variable, we look the variable up in memory (using lookup). This returns a maybe value, which we then pass to maybeToEither, which will return
-- either an integer value (of the value of the variable in memory if it existed), or an error if there was a nothing value (and so the variable is uninitialised)
evaluate (VarE x) mem = maybeToEither (lookup x mem)
-- This case runs when the expression was a binary operator, and so has a binary operator and two parameters.
evaluate (BinOpE f x y) mem = do
  --These two parameters could be further binary operators, and so we recursively call the parameters until they terminate at either a value or a variable.
  a <- evaluate x mem
  b <- evaluate y mem
  -- This checks whether the operator is in the list operatorList, and if so, calls the function calculate, passing in the operator wrapped in a maybe container as a parameter.
  -- The lookup function is used to extract the second value from the tuple in the list where the first element equals the string equivalent of the operation. (e.g lookup "Add" will return Maybe +)
  -- It is wrapped in a maybe type as there may be an element in the list or not (even though we know that an element will always exist).
  if any ((== show f).fst) operatorList then Right (calculate (lookup (show f) operatorList) a b)
  -- This checks whether the operation is boolean, and if so, extracts it from the list in the same way as above
  else if any ((== show f).fst) booleanOperatorList then Right (calculate (lookup (show f) booleanOperatorList) a b)
  else
    -- The only two possibilities left are division and power, and these were seperate as they each have specific errors, and thus need error handling
    case f of
      -- The function opError is expalined below, but this passes in the booleanFunction to check the parameters a and b against, the arithmatic expression to perform if the parameters are correct,
      -- the parameters themselves, and then the error to return if need be.
      Div -> opError (==) quot a b DivByZeroError
      Pow -> opError (<) (^) a b NegativeExponentError


-- EXTENSION (I'm implementing booleans operators such as AND and OR and boolean operands such as True or False )
-- Returns a truth value
evaluate (ValB True) mem = Right (1)
evaluate (ValB False) mem = Right (0)
-- This case runs when a boolean operator is called
evaluate (BinOpB f x y) mem = do
    -- These two parameters could be further operations, and so we can recursively call the parameters until they terminate
    a <- evaluate x mem
    b <- evaluate y mem
    -- Run the code for And
    if (show(f) == "And") then Right ( evalAnd a b )
    else Right (evalOr a b)

-- This function evaluates AND statements
evalAnd :: Int -> Int -> Int
evalAnd a b
  | a ==1 && b==1 = 1
  | otherwise =0

-- This function evaluates or statements
evalOr :: Int -> Int -> Int
evalOr a b
  | a ==0 && b ==0 = 0
  | otherwise = 1




-- The parameter x is the function wrapped in a maybe container. We can use applicatives to apply this function to the parameters, also wrapped in maybe containers.
-- This will return the result of the calculation (either an arithmatic value or a boolean expression (True or False) also wrapped in Maybe)
-- The fromJust function is imported from Data.Maybe and unwraps the result from its maybe container, and this is applied to fromEnum
-- FromEnum returns a numerical value if one is entered (and so any arithmatic expression is untouched), but if provided with true/false, will return 1 for true and 0 for false
calculate :: Enum a => Maybe (Int -> Int -> a) -> Int -> Int -> Int
calculate x a b = fromEnum $ fromJust $ x <*> Just a <*> Just b


-- This function was written to deal with the error scenarios for the division and power operators. In either case, there was a condition that if either the parameters
-- met, then there would be an error. For division, this was if either parameter was 0, and for power it was if either was less than 0. Therefore, the BooleanFunction parameter
-- is used to represent this function. The arithmatic function is the operation to perform on the data should the boolean function not be applicable, and thus the data correct.
-- As the function was passed as a parameter, I had to infix it using ``. If either parameters fail the booleanFunction then the inputted error is outputted.
-- Otherwise, we return the integer result of the arithmatic calculation (hence why we use `quot` to get the integer division)
opError :: BooleanFunction -> ArithmaticFunction -> Int -> Int -> Err -> Either Err Int
opError booleanFunction arithmaticFunction a b err
  | a `booleanFunction` 0 || b `booleanFunction` 0 = Left err
  | otherwise = Right (a `arithmaticFunction` b)


-- This function is used to convert from maybe to the either type
-- When a variable name is passed in, the memory is searched for the variable. This returns a maybe value (either the value of the variable or nothing)
-- If there is a value, this is returned as an either. If not, then the uninitialised memory value is returned

maybeToEither :: Maybe Int -> Either Err Int
maybeToEither (Just x)  = Right x
maybeToEither Nothing = Left (UninitialisedMemory "x")





-- This code was written to evaluate IF statements. Again, I passed in the seperate aspects of the IF statements as seperate parameters, so that the code is easier to read.
-- This code is recursive, and essentially checks the given condition, and if it is correct, then it executes the body. If not, then it checks whether there are more conditions to check in the
-- list of elseIf conditions, until either a condition is met, or the else If conditions run out, in which case the default else is run.
ifStmt :: Expr -> [Stmt] -> [(Expr,[Stmt])] -> [Stmt] -> Memory -> Either Err Memory
ifStmt condition body elseIfConds elseBody mem = ifDecision (evaluate condition mem)
  where
    -- Returns the error if there was one
    ifDecision (Left x) = Left x
    -- If the expression evaluated to 0 then it was false. This means we either need to check the next else if or run the else
    ifDecision (Right 0)
      -- If there are no more else ifs to check, then the else clause runs as default. Interpret is called, and the list of statements passed in
      | null elseIfConds = interpret elseBody mem
      -- If elseIfConds has some elements, then the next one is passed in as the primary condition to be checked on the next recursive call. The remaining list is also passed in, as well as
      -- the memory and the else clause (for when the program eventually unwinds)
      | otherwise = ifStmt (fst (head elseIfConds)) (snd (head elseIfConds)) (drop 1 elseIfConds) elseBody mem
    -- Evaluate returned a Right value of greater than 0. This means that the condition evaluated to true and so we run the body of the statement
    ifDecision (Right x) = interpret body mem



-- This function repeats for as many times as defined within the parameter counter. With every call, the body of the repeat construct is passed into interpret so that it can be run.
repeatStmt :: Int -> [Stmt] -> Memory -> Either Err Memory
-- When counter is 0, then we return the memory
repeatStmt 0 stmt mem = return mem
-- While there is a counter, we have to run the repeat body
repeatStmt counter stmt mem
  -- Deals with negative numbers
  | counter < 0 = return mem
  -- We call interpret, passing in the list of statements to be run, and the memory, as parameters. The result of this (either an error or memory) is returned. Using the bind operator, it is
  -- decontained from its either container, and is bound to the variable x. If there was an error, this error is returned. If a new memory was returned, then this is passed into the next
  -- recursive call of repeatLoop as the memory parameter. We also decrement the counter
  | otherwise = interpret stmt mem >>= \x -> repeatStmt (counter -1) stmt x




-- EXTENSION
-- There are tests for this in Spec.hs

-- This function deals with while loops
whileStmt :: Expr -> [Stmt] -> Memory -> Either Err Memory
whileStmt cond body mem = whileDecision (evaluate cond mem)
    where
      -- Return the error
      whileDecision (Left x) = Left x
      -- The condition evaluated to false and so we've reached our base condition
      whileDecision (Right 0) = return mem
      -- Otherwise the condition was true, and so we run the loop again
      whileDecision (Right x) = interpret body mem >>= \z -> whileStmt cond body z


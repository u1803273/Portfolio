/* Some of this code is based off of code provided in labs and so does not belong to me. Hashmap is an example of this */

/**
 *  In this file, I used a hash map to store all the users, hashing the unique ID to generate the hash addresses.
    Each location in the hash table stores a linked list, with each list element being a key value pair.
    Each key will be the user id, and the value an object of type User
    This code is edited from the one provided within the labs

    This class contains methods to search through users via their id's and their dates. I was deliberating between a binary tree
    implementation or a hash map, but if I were to use binary trees, I would need to implement two of them, one ordering on ID
    and one on dates, so that I could quickly search both of them. However, this is not very memory efficient. Therefore, I chose a hash
    map because although it comes with an increased overhead, and memory cells that are allocated and may never be filled, this is far less
    than storing every value twice in a binary tree. These binary trees would also use lots of computational power maintaining order
    when items are added (such as adjusting pointers when a new value is added) and this again is a big negative.

    Hashing is very quick to insert O(1), and when searching by id is very fast as well , again being O(1).
    However, it is slower searching on things that aren't the key, as every value needs to be retrieved. This leads to an o(n)
    time complexity, as every element is pulled out, and then checked whether it fits the criteria. Although this is less than ideal,
    it is a comprimise I made against using trees.

    I believe that the benefits of the hash table outweigh the negatives, especially considering that other implementations
    would have significant memory overheads, and require additional computational power to be implemented. This is especially
    prominent when dealing with large numbers of users, and then having to store them all twice.

    I created a quicksort to sort the arrays. Initially, everytime I had located a new user to add to the array,
    it was inserted into its correct index, and then every other element was shifted along. However, this insertion sort had
    a time complexity of 0(n^2) and so is incredibly inefficient, especially when considering large data sets. So, I opted to using
    a quicksort. This has an average case complexity of 0(nlogn) which is less than insertion, and requires less computational power, as
    the sort is run once on all data, as opposed to after every element was inserted.
    I selected quick sort over merge sort because of its space complexity. Merge sort has the same time complexity, but requires 0(2n)
    storage, whereas quick sort is simply 0(n). Due to the fact quick sort doesn't store every element twice, I chose this approach.

    I also created tests to test all of the methods implemented below, and these can be found in the tests folder inside the file WeetTests.java

 * @author: U1803273
 */

package uk.ac.warwick.java.cs126.services;

import uk.ac.warwick.java.cs126.models.User;

import java.util.Date;
//import HashMap;

//@SuppressWarnings("unchecked")
public class UserStore implements IUserStore {

    private HashMap hashTable = new HashMap();
    // This variable is used by the search functions and stores the number of elements inserted into the array (regardless of its capacity)
    protected int size = 0;
    // This is used to shrink the array so there are no empty/null elements
    protected int searchIndex =0;

    public UserStore() {
    }

    public int getSize(){
      return this.size;
    }

    // This method adds a new user to the hash table
    // The User object will have 3 elements: (name, id, date)
    public boolean addUser(User usr) {
        // If already in hashTable, then not added again.
        if (hashTable.get(usr.getId())!=null){
          return false;
        } // As not in the hash table, we add the user
        else{
          hashTable.add(usr.getId(),usr);
          this.size++;
          return true;
        }
    }

    // This method returns the user with id 'uid'
    public User getUser(int uid) {
      // We have to explicitely type cast to type User to avoid errors, as we are moving from parametric type V to User
        return (User)hashTable.get(uid);
    }

    // This function returns a list of all users in the hash table.
    // The shrink function is used to reduce the size of the array, as there will be empty spaces at the end. But it is more efficient to double the size
    // of the array everytime, and end up with spaces, than only increase it by one each time an element is added.
    public User [] getUsers(){
      // Although it looks slightly ugly to call the search function with only one actual parameter, the following functions were incredibly repetitive
      // and had identical code, except for the conditions upon which a user was added to the array. This is why I abstracted a function to handle this.
      return search (null, null, 1);
    }

    // This function returns a list of all users that have names containing the search query. Again, shrink is used to reduce the length of the array
    public User [] getUsersContaining(String query){
      return search (query, null, 2);
    }

    // This function is used to get all users who joined before a certain date. That means their date is before the given date
    public User [] getUsersJoinedBefore(Date dateBefore){
      return search (null, dateBefore, 3);
    }

    // This is a private method so that other classes cannot access it. This method goes through the array and copies the elements across to a new,
    // reduced length array. Although it has a time complexity of O(n), there is no other way to perform this action.
    private User [] shrink (User [] users_long){
      // We need to iterate through the array and print only the actual items to the new array
      //System.out.println("shrink search index: " + this.searchIndex);
      User [] users_short = new User [this.searchIndex];
      for (int i=0; i<this.searchIndex;i++){
        users_short[i] = users_long[i];
      }
      return users_short;
    }

    /*
    getUsers, getUsersContaining and getUsersJoinedBefore were all almost identical in their functionality
    Each one iterated through the hashmap, and returned all users that matched some specificed search criteria.
    The only thing that differed was the if statement that was used as a filter.
    Therefore, this function generalises this process, and avoids repetitive code.
    The choice parameter dictates the mode selected
    1: getUsers (so no criteria)
    2: getUsersContaining (so a string)
    3: getUsersJoinedBefore (so a date)
    */
    public User [] search (String query, Date dateBefore, int choice){
      // Sets the searchIndex var to 0, so it can be increased for every element added to the user array
      this.searchIndex=0;
      // This stores the locations in the hash table that actually have values stores in them
      // Stops us checking entries that are empty
      int [] locations = hashTable.getArray();
      User [] users;
      // If getUsers is called, all elements are returned so the array is initialised to the size of the hash map ( to save computational
      // power constantly resizing).
      if (choice ==1){
        users = new User [getSize()];
      }// Else, we set the array to something small to save space, but can be increased if and when required
      else{
        users = new User [10];
      }

      //  This variable is used to hold the index in the array to add the next element to
      int index =0;
      // We now need to check every linked list at index i from locations
      int i =0;
      while (locations[i]!=-1){
        // The index at location[i] contains a pointer to a hash table linked list.
        // We need to visit this list and get the elements stored there.
        User [] new_users = hashTable.returnAll(locations[i]);
        // returnAll returns all users at that index in the linked list
        // This cannot be null as it was taken from the array locations
        // Index variable for new_users
        int k =0;
        // While there are still elements in the new_users array
        while (k<new_users.length){
          if (choice == 1){
            users[index] = new_users[k];
            index++;
          }// Either 2 or 3. Both may need the resize method called
          else{
            // Check the array isn't full
            if (users[users.length -1]!=null){
              // Call resise method
              users = resize(users);
            }
            // Now we switch choice, and select the if statement we need
            switch (choice){
              // getUsersContaining
              case 2:
              query = query.toLowerCase();
                // Gets the name of user in lower case
                String name = new_users[k].getName().toLowerCase();
                // Checks whether the name contains the search query term
                if (name.indexOf(query)!=-1){
                  // It does, so we add to our list of users
                  users[index] = new_users[k];
                  index++;
                }
                break;

              // getUsersJoinedBefore
              case 3:
                // Checks if the user has a date before the parameter passed in
                if (new_users[k].getDateJoined().before(dateBefore)){
                  // Date was before, and so needs to be added to the list
                  users[index] = new_users[k];
                  index++;
                }
                break;
              }
          }
          k++;
        }
        i++;
      }
      // Sets search index to the number of elements added (value of 'index')
      this.searchIndex = index;
      users=shrink(users);

      QuickSort quickSort = new QuickSort();
      users = quickSort.sort(users, 0, users.length-1);
      return users;
    }


    // This function inserts an item into the array, ensuring the date order is maintained
    public User[] insert(User [] users, User new_user){
      // Increments the searchIndex count variable
      this.searchIndex++;
      //System.out.println("Inside insert function");
        // The method getDateJoined returns the value of date from the user object
        Date date = new_user.getDateJoined();
        // We will use the date to order the array
        int i =0;
        //System.out.println("users length: " + users.length);
        while (users[i]!=null){
          //System.out.println("i: "+i);
          // Compares the date of the object to be inserted with that of the date of the user at that index
          if (date.after(users[i].getDateJoined())){
            // The new date is smaller than the date at i (therefore is inserted to this index)
            //System.out.println("break");
            break;
          }
          //System.out.println("no if");
          i++;
        }
        //System.out.println("end i: "+i);
        // Now i stores the index to insert the new item. But we need to shuffle the rest of the items along
        User temp = new_user;
        // This while loop iterates until either an element becomes null (and so the end of the elements are reached)
        // or the end of the array is reached (and so nothing more needs to be added)
        User temp2 = null;
        while ( temp != null){
          // Sets temp2 to the item being replaced
          temp2 = users[i];
          // Replaces i with the item
          users[i] = temp;
          // Temp is set to temp2, so that next iteration, temp2 replaces the next index and so on
          temp = temp2;
          i++;
        }
        // Temp now holds the last element in the list
        // users[i] = temp;
        return users;

    }

    // This resizes the array for the getUsersJoinedBefore function if its capacity is reached
    public User[] resize(User [] users){
      User [] new_users = new User [users.length*2];
      for (int i=0; i<users.length; i++){
        new_users[i] = users[i];
      }
      return new_users;
    }


    // These functions are for testing purposes and so allow me to call embedded functions. They are not used in the program
    public int[] getArrays(){
      return hashTable.getArray();
    }


    // This class is a quick sort
    class QuickSort {
      protected User [] users;

      // This is an implementation of the quicksort algorithm. It will take an unordered list of users and sort them by their dates.
      // I chose quicksort over mergesort for its reduced memory requirements, as mergesort has a space complexity of O(2n)
      public User [] sort (User [] users, int start, int end ){
          // While the length of the sublist is still greater than 0
          if (start<end){
            // We need to partition the list (partition returns the index of the split point)
            int split = partition (users, start, end);
            //System.out.println("split "+split);
            //System.out.println("sort 1; start end " + start +" "+ (split-1));
            sort (users, start, split-1);
            //System.out.println("sort 2; start end " + (split+1) +" "+ end);
            sort (users, split +1, end);
          }
          return users;
      }

      private int partition (User [] users, int start, int end){
        User pivot = users[start];
        // These are the pointers that will be used to partition the list
        int leftMark = start + 1;
        int rightMark = end;
        // Acts as a boolean flag
        Boolean done = false;
        // Used in a lot of conditions, so less power to define once instead of retrieving each time
        Date date = pivot.getDateJoined();
        while (done == false ){
          // We check every element at position leftMark and compare it against the current value in rightMark, until either the pointers cross over,
          // or the value in leftMark is older than that in RightMark, and so they need to be swapped over.
          while ((leftMark <= rightMark) && (users[leftMark].getDateJoined().after(date) || users[leftMark].getDateJoined().equals(date) ) ){
            leftMark ++;
            //System.out.println("leftmarker");
          }
          // Now we move the right marker done, until either the pointers swap, or we reach an element more recent than right marker (which will later then need
          // to be swapped )
          while ( (rightMark >= leftMark) && (users[rightMark].getDateJoined().before(date))){
            rightMark --;
            //System.out.println("rightmarker");
          }
          // Now either the pointers have crossed over, or we need to swap elements
          // Checks if pointers have swapped
          if (rightMark < leftMark){
            // The pointers have swapped and so the list is ordered
            done = true;
            //System.out.println("done");
          }// We need to swap the elements
          else {
            //System.out.println("swap");
            User temp = users [leftMark];
            users [leftMark] = users [rightMark];
            users [rightMark] = temp;
          }
        }

        // Now the list is positioned, but we need to swap the pivot with the element currently at position rightMark (as left marker went to the other
        //side of left marker, and so holds the last element sequentially that is less than the pivot (the start element))
        User temp = users [start];
        users[start] = users[rightMark];
        users[rightMark] = temp;
        // Return the split point (where all elements to LHS are smaller, and RHS are bigger)
        return rightMark;

      }

    }


    /**
    * An interface for a generic map, from keys of type K to values of type V.
    */
    interface IMap<K,V> {

        // Adds a mapping from key to value to the map
        public void add(K key, V value);

        // Finds the respective value that is mapped to from key
        public V get(K key);


    }

    // This line allows us to cast our object to type (E) without any warnings.
    // This code was edited from that supplied by the CS126 labs
    // For further detais, please see: http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/SuppressWarnings.html
    @SuppressWarnings("unchecked")
    class HashMap<K extends Comparable<K>,V> implements IMap<K,V> {

        protected KeyValuePairLinkedList[] table;
        // This stores a list of the hash locations that actually have values stored at them, thus reducing the time it takes to search
        protected int [] locations;
        // Stores the index of the next free element to locations
        private int i =0;

        public HashMap() {
            /* for very simple hashing, primes reduce collisions */
            // Choosing 199 as this is large and prime. If to be scaled up to 500,000 users, we would need a drastically larger table
            this(199);
        }

        public HashMap(int size) {
            table = new KeyValuePairLinkedList[size];
            initTable();
            // This initialises all elements in the array to -1 (which will act as the null value)
            locations = new int[table.length];
            for (int i=0; i<locations.length; i++){
              locations[i]=-1;
            }
        }

        protected void initTable() {
            for(int i = 0; i < table.length; i++) {
                table[i] = new KeyValuePairLinkedList<>();
            }
        }

        protected int hash(K key) {
            int code = key.hashCode();
            return code;
        }

        public int mod(K key){
          return key.hashCode() % table.length;
        }

        // Returns whether an element is in the array or not
        public boolean isElement(int location){
          for (int i=0; i<locations.length; i++){
            // The element is part of the array
            if (locations[i]==location){
              return true;
            }
          }
          return false;
        }

        public void add(K key, V value) {
            int hash_code = hash(key);
            int location = hash_code % table.length;
            // We need to add the new location to the array unless its already in there
            boolean result = isElement(location);
            // The element is not in the array
            if (result == false){
              locations[this.i]=location;
              this.i++;
            }

            //System.out.println("Adding " + value + " under key " + key + " at location " + location);

            table[location].add(key,value);
        }

        public int getSize(){
          return table.length;
        }

        // Returns the array locations
        public int[] getArray(){
          return this.locations;
        }

        public V get(K key) {
          // Gets the hash of the key
            int hash_code = hash(key);
            // Location points to the element in the table that the key pointed to (this element is a linked list)
            int location = hash_code % table.length;

            // ptr stores the first element of the linked list
            ListElement<KeyValuePair> ptr = table[location].head;

            // table location is the linked list
            // .get(key) goes through the linked list until the key is reached
            // Returns the key value pair with the correct key
            // getValue returns the value from the K,V pair
            // return (V)table[location].get(key).getValue();

            // This returns the list element of the linked list with the key
            KeyValuePair value = table[location].get(key);
            // If this is null, then there is no element.
            if (value==null){
              return null;
            }else{
              return (V)value.getValue();
            }
        }

        public User[] returnAll (int location){
          // We need to return all users at location, and so need an array pf length users[location]
          return table[location].returnAtLocation();

        }

    }


    class KeyValuePairLinkedList<K extends Comparable<K>,V> {

        protected ListElement<KeyValuePair<K,V>> head;
        protected int size;

        public KeyValuePairLinkedList() {
            head = null;
            size = 0;
        }

        public void add(K key, V value) {
            this.add(new KeyValuePair<K,V>(key,value));
        }

        public void add(KeyValuePair<K,V> kvp) {
            ListElement<KeyValuePair<K,V>> new_element =
                    new ListElement<>(kvp);
            new_element.setNext(head);
            head = new_element;
            this.size++;
        }

        public int size() {
            return this.size;
        }

        public ListElement<KeyValuePair<K,V>> getHead() {
            return head;
        }

        public KeyValuePair<K,V> get(K key) {
            ListElement<KeyValuePair<K,V>> temp = head;
            // temp is an element of the list (or a member of the list element class)
            // therefore, temp.getvalue returns the value of the linked list element (or the KV pair, not the value of this pair, the entire pair itself)
            // THEN getKey gets the key from the pair
            while(temp != null) {
                if(temp.getValue().getKey().equals(key)) {
                    return temp.getValue();
                }

                temp = temp.getNext();
            }

            return null;
        }

        public User [] returnAtLocation(){
          ListElement<KeyValuePair<K,V>> temp = head;
          User [] users = new User [size()];
          int i =0;
          while(temp != null) {
              users [i] = (User) temp.getValue().getValue();
              i++;
              temp = temp.getNext();
          }

          return users;
        }


    }



    class ListElement<E> {
        private final E value;
        private ListElement<E> next;
        private ListElement<E> prev;

        public ListElement(E value) {
            this.value = value;
        }

        public E getValue() {
            return this.value;
        }

        public ListElement<E> getNext() {
            return this.next;
        }

        public ListElement<E> getPrev() {
            return this.prev;
        }

        public void setNext(ListElement<E> e) {
            this.next = e;
        }

        public void setPrev(ListElement<E> e) {
            this.prev = e;
        }

    }



    class KeyValuePair<K extends Comparable<K>,V> implements Comparable<KeyValuePair<K,V>> {

        protected K key;
        protected V value;
        //protected User value;

        public KeyValuePair(K k, V v) {
            key = k;
            value = v;
        }

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public int compareTo(KeyValuePair<K,V> o) {
            return o.getKey().compareTo(this.getKey());
        }
    }

}
